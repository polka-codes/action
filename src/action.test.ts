import { type Mock, afterEach, beforeEach, describe, expect, mock, test } from 'bun:test'
// Generated by polka.codes
import { spawnSync } from 'node:child_process'
import * as core from '@actions/core'
import * as github from '@actions/github'
import { run } from './action'

// Mock external modules
mock.module('node:child_process', () => ({
  spawnSync: mock(),
}))

const coreMocks = {
  getInput: mock(),
  info: mock(),
  error: mock(),
  setFailed: mock(),
  debug: mock(),
  getIDToken: mock(),
  warning: mock(),
}
mock.module('@actions/core', () => coreMocks)

const githubMocks = {
  getOctokit: mock(),
  context: {
    repo: {
      owner: '',
      repo: '',
    },
  },
}
mock.module('@actions/github', () => githubMocks)

const mockedSpawnSync = spawnSync as unknown as Mock<typeof spawnSync>
const mockedCore = core as unknown as typeof coreMocks
const mockedGithub = github as unknown as typeof githubMocks

const octokitMock = {
  rest: {
    pulls: {
      get: mock(),
      createReview: mock(),
    },
    issues: {
      createComment: mock(),
    },
  },
}

mockedGithub.getOctokit.mockReturnValue(octokitMock as any)

describe('Polka Codes GitHub Action', () => {
  beforeEach(() => {
    // Set up mock context
    mockedGithub.context.repo.owner = 'test-owner'
    mockedGithub.context.repo.repo = 'test-repo'

    // Mock GITHUB_TOKEN
    process.env.GITHUB_TOKEN = 'test-token'
  })

  afterEach(() => {
    mockedSpawnSync.mockClear()
    for (const m of Object.values(coreMocks)) {
      m.mockClear()
    }
    mockedGithub.getOctokit.mockClear()
    octokitMock.rest.pulls.get.mockClear()
    octokitMock.rest.pulls.createReview.mockClear()
    octokitMock.rest.issues.createComment.mockClear()
  })

  describe('review mode', () => {
    test('should post a PR review with specific comments', async () => {
      // Mock inputs
      mockedCore.getInput.mockImplementation((name: string) => {
        switch (name) {
          case 'review':
            return 'true'
          case 'pr_number':
            return '123'
          case 'cli_version':
            return 'latest'
          default:
            return ''
        }
      })

      // Mock CLI output
      const reviewOutput = {
        overview: 'This is a test overview.',
        specificReviews: [
          {
            file: 'src/main.ts',
            lines: '10-15',
            review: 'This is a test review comment.',
          },
          {
            file: 'src/another.ts',
            lines: '20',
            review: 'Another comment.',
          },
          {
            file: 'src/invalid.ts',
            lines: 'abc',
            review: 'Invalid line.',
          },
        ],
      }
      mockedSpawnSync.mockReturnValue({
        status: 0,
        stdout: JSON.stringify(reviewOutput),
        stderr: '',
        error: undefined,
        signal: null,
      } as any)

      // Mock octokit
      octokitMock.rest.pulls.get.mockResolvedValue({
        data: {
          head: {
            sha: 'test-sha',
          },
        },
      } as any)

      await run()

      expect(mockedCore.info).toHaveBeenCalledWith('Starting review process...')
      expect(mockedSpawnSync).toHaveBeenCalledWith('npx', ['@polka-codes/cli@latest', 'review', '--json'], { encoding: 'utf-8' })
      expect(octokitMock.rest.pulls.createReview).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        pull_number: 123,
        commit_id: 'test-sha',
        body: 'This is a test overview.',
        event: 'COMMENT',
        comments: [
          {
            path: 'src/main.ts',
            body: 'This is a test review comment.',
            start_line: 10,
            line: 15,
          },
          {
            path: 'src/another.ts',
            body: 'Another comment.',
            line: 20,
          },
        ],
      })
      expect(mockedCore.warning).toHaveBeenCalledWith('Invalid lines format: "abc". It will be ignored.')
    })

    test('should post an issue comment with the overview', async () => {
      // Mock inputs
      mockedCore.getInput.mockImplementation((name: string) => {
        switch (name) {
          case 'review':
            return 'true'
          case 'issue_number':
            return '456'
          case 'cli_version':
            return 'latest'
          default:
            return ''
        }
      })

      // Mock CLI output
      const reviewOutput = {
        overview: 'This is a test overview for an issue.',
        specificReviews: [],
      }
      mockedSpawnSync.mockReturnValue({
        status: 0,
        stdout: JSON.stringify(reviewOutput),
        stderr: '',
        error: undefined,
        signal: null,
      } as any)

      await run()

      expect(mockedCore.info).toHaveBeenCalledWith('Starting review process...')
      expect(octokitMock.rest.issues.createComment).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 456,
        body: 'This is a test overview for an issue.',
      })
    })

    test('should throw an error if the review command fails and log stdout and stderr', async () => {
      // Mock inputs
      mockedCore.getInput.mockImplementation((name: string) => {
        switch (name) {
          case 'review':
            return 'true'
          case 'pr_number':
            return '123'
          default:
            return ''
        }
      })

      // Mock failed CLI command
      mockedSpawnSync.mockReturnValue({
        status: 1,
        stdout: 'CLI stdout',
        stderr: 'CLI stderr',
        error: undefined,
        signal: null,
      } as any)

      await run()

      expect(mockedCore.setFailed).toHaveBeenCalledWith('Review command failed with exit code 1')
      expect(mockedCore.error).toHaveBeenCalledWith('Review command stderr: CLI stderr')
      expect(mockedCore.error).toHaveBeenCalledWith('Review command stdout: CLI stdout')
    })

    test('should fall back to a general comment if createReview fails', async () => {
      // Mock inputs
      mockedCore.getInput.mockImplementation((name: string) => {
        switch (name) {
          case 'review':
            return 'true'
          case 'pr_number':
            return '123'
          default:
            return ''
        }
      })

      const reviewOutput = {
        overview: 'This is an overview.',
        specificReviews: [{ file: 'src/main.ts', lines: '1', review: 'A comment.' }],
      }
      mockedSpawnSync.mockReturnValue({ status: 0, stdout: JSON.stringify(reviewOutput) } as any)
      octokitMock.rest.pulls.get.mockResolvedValue({ data: { head: { sha: 'test-sha' } } } as any)
      octokitMock.rest.pulls.createReview.mockRejectedValue(new Error('API error'))

      await run()

      expect(mockedCore.warning).toHaveBeenCalledWith('Failed to create PR review. Falling back to a general comment. Error: API error')
      expect(octokitMock.rest.issues.createComment).toHaveBeenCalledWith({
        owner: 'test-owner',
        repo: 'test-repo',
        issue_number: 123,
        body: 'Polka Codes review overview:\n\nThis is an overview.',
      })
    })

    test('should fail if JSON parsing fails', async () => {
      mockedCore.getInput.mockImplementation((name: string) => {
        switch (name) {
          case 'review':
            return 'true'
          case 'pr_number':
            return '123'
          default:
            return ''
        }
      })
      mockedSpawnSync.mockReturnValue({ status: 0, stdout: 'invalid json' } as any)

      await run()

      expect(mockedCore.setFailed).toHaveBeenCalledWith(
        'Invalid JSON received from review command. Expected { "overview": string, "specificReviews": [...] }',
      )
    })

    test('should fail if config path is invalid', async () => {
      mockedCore.getInput.mockImplementation((name: string) => {
        switch (name) {
          case 'review':
            return 'true'
          case 'pr_number':
            return '123'
          case 'config':
            return '../invalid/path'
          default:
            return ''
        }
      })

      await run()

      expect(mockedCore.setFailed).toHaveBeenCalledWith('Invalid or disallowed character in config path: ../invalid/path')
    })
  })
})
