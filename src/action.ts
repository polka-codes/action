// Generated by polka.codes
// Main entry point for the Polka Codes GitHub Action

import { spawnSync } from 'node:child_process'
import { platform } from 'node:os'
import * as core from '@actions/core'
import { exec } from '@actions/exec'
import * as github from '@actions/github'
import { fetchIssue, fetchPR } from '@polka-codes/github'

interface SpecificReview {
  file: string
  lines: string // e.g., '10' or '10-15'
  review: string
}

interface ReviewOutput {
  overview: string
  specificReviews: SpecificReview[]
}

interface ActionInputs {
  issueNumber?: number
  prNumber?: number
  task?: string
  config?: string
  cliVersion: string
  runnerPayload?: string
  runnerApiUrl: string
  review: boolean
}

async function getInputs(): Promise<ActionInputs> {
  core.debug('Getting action inputs')
  const issueNumberStr = core.getInput('issue_number')
  const prNumberStr = core.getInput('pr_number')

  const inputs = {
    issueNumber: issueNumberStr ? Number.parseInt(issueNumberStr) : undefined,
    prNumber: prNumberStr ? Number.parseInt(prNumberStr) : undefined,
    task: core.getInput('task'),
    config: core.getInput('config'),
    cliVersion: core.getInput('cli_version'),
    runnerPayload: core.getInput('runner_payload'),
    runnerApiUrl: core.getInput('runner_api_url'),
    review: core.getInput('review') === 'true',
  }

  core.debug(
    `Received inputs: issue=${issueNumberStr}, pr=${prNumberStr}, task=${inputs.task}, config=${inputs.config}, review=${inputs.review}`,
  )
  return inputs
}

const validateInputs = (inputs: ActionInputs) => {
  core.debug('Validating inputs')

  if (inputs.runnerPayload) {
    // remote runner mode

    if (inputs.issueNumber || inputs.prNumber || inputs.task) {
      const error = 'issue_number, pr_number, or task cannot be used when used as remote runner'
      core.error(error)
      throw new Error(error)
    }
    return
  }

  if (inputs.review) {
    if (!inputs.prNumber && !inputs.issueNumber) {
      throw new Error('Review mode requires either a "pr_number" or "issue_number" input.')
    }
    if (inputs.task) {
      core.warning('The "task" input is ignored when in review mode.')
    }
    return
  }

  if (inputs.issueNumber && inputs.prNumber) {
    const error = 'Only one of issue_number or pr_number can be provided'
    core.error(error)
    throw new Error(error)
  }

  if (!inputs.issueNumber && !inputs.prNumber && !inputs.task) {
    const error = 'One of issue_number, pr_number, or task must be provided'
    core.error(error)
    throw new Error(error)
  }
}

const sanitizePath = (path: string): string => {
  const trimmedPath = path.trim()
  if (trimmedPath.includes('..') || /[&;|`<>!$*]/.test(trimmedPath)) {
    throw new Error(`Invalid or disallowed character in config path: ${trimmedPath}`)
  }
  return trimmedPath
}

const remoteRunner = async (inputs: { runnerPayload: string; cliVersion: string; runnerApiUrl: string }) => {
  const payload = JSON.parse(inputs.runnerPayload)
  if (payload.ref) {
    spawnSync('git', ['fetch', 'origin', payload.ref], { stdio: 'inherit' })
    spawnSync('git', ['checkout', payload.ref], { stdio: 'inherit' })
  }
  const oidcToken = await core.getIDToken('https://polka.codes')
  spawnSync(
    'npx',
    [
      `@polka-codes/runner@${inputs.cliVersion}`,
      '--task-id',
      payload.taskId,
      '--session-token',
      payload.sessionToken,
      '--github-token',
      oidcToken,
    ],
    { stdio: 'inherit' },
  )
}

async function handleReview(inputs: ActionInputs): Promise<void> {
  core.info('Starting review process...')
  const octokit = github.getOctokit(process.env.GITHUB_TOKEN ?? '')
  const { owner, repo } = github.context.repo

  // Re-use config logic from the `run` function.
  let configArgs: string[] = []
  if (inputs.config) {
    const configPaths = inputs.config.split(',').map(sanitizePath)
    configArgs = configPaths.flatMap((path) => ['--config', path])
    core.info(`Using config files for review: ${configPaths.join(', ')}`)
  }

  core.info('Executing review command...')
  const reviewCommand = spawnSync('npx', [`@polka-codes/cli@${inputs.cliVersion}`, ...configArgs, 'review', '--json'], {
    encoding: 'utf-8',
  })

  if (reviewCommand.error) {
    throw new Error(`Failed to execute review command: ${reviewCommand.error.message}`)
  }

  if (reviewCommand.status !== 0) {
    const errorMessage = `Review command failed with exit code ${reviewCommand.status}`
    core.error(errorMessage)
    core.error(`Review command stderr: ${reviewCommand.stderr}`)
    if (reviewCommand.stdout) {
      core.error(`Review command stdout: ${reviewCommand.stdout}`)
    }
    throw new Error(errorMessage)
  }

  const jsonOutput = reviewCommand.stdout
  let reviewData: ReviewOutput
  try {
    reviewData = JSON.parse(jsonOutput)
  } catch (e) {
    core.error('Failed to parse JSON output from review command.')
    if (e instanceof Error) {
      core.error(`Parsing error: ${e.message}`)
    }
    core.debug(`Received output for debugging: ${jsonOutput}`)
    throw new Error('Invalid JSON received from review command. Expected { "overview": string, "specificReviews": [...] }')
  }

  const { overview, specificReviews } = reviewData
  const issue_number = inputs.prNumber ?? inputs.issueNumber

  if (!issue_number) {
    // This case is handled by `validateInputs`, but as a safeguard.
    throw new Error('No PR or issue number found for review posting.')
  }

  const postGeneralComment = async (fallbackMessage?: string) => {
    if (overview) {
      core.info(`Posting overview as a general comment to #${issue_number}.`)
      const body = fallbackMessage ? `${fallbackMessage}\n\n${overview}` : overview
      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number,
        body,
      })
    }
  }

  if (specificReviews.length > 0 && inputs.prNumber) {
    core.info(`Posting a PR review with up to ${specificReviews.length} specific comments.`)
    const { data: pr } = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number: inputs.prNumber,
    })

    const parseLines = (lines: string): { line: number; start_line?: number } | null => {
      const trimmedLines = lines.trim()
      if (/^\d+$/.test(trimmedLines)) {
        const line = Number(trimmedLines)
        return line > 0 ? { line } : null
      }
      if (/^\d+-\d+$/.test(trimmedLines)) {
        const [start, end] = trimmedLines.split('-').map(Number)
        if (start >= 1 && end >= start) {
          return { start_line: start, line: end }
        }
      }
      core.warning(`Invalid lines format: "${lines}". It will be ignored.`)
      return null
    }

    const reviewComments = specificReviews.flatMap(({ file, lines, review }) => {
      const lineInfo = parseLines(lines)
      if (lineInfo) {
        return [{ path: file, body: review, ...lineInfo }]
      }
      return []
    })

    if (reviewComments.length > 0) {
      try {
        await octokit.rest.pulls.createReview({
          owner,
          repo,
          pull_number: inputs.prNumber,
          commit_id: pr.head.sha,
          body: overview,
          event: 'COMMENT',
          comments: reviewComments,
        })
      } catch (error) {
        const message = `Failed to create PR review. Falling back to a general comment. Error: ${
          error instanceof Error ? error.message : 'Unknown error'
        }`
        core.warning(message)
        await postGeneralComment('Polka Codes review overview:')
      }
    } else {
      await postGeneralComment()
    }
  } else if (overview) {
    await postGeneralComment()
  } else {
    core.info('No overview or specific reviews to post.')
  }
}

export async function run(): Promise<void> {
  try {
    if (platform() === 'linux') {
      try {
        await exec('rg', ['--version'], { silent: true })
        core.debug('ripgrep is already installed.')
      } catch (error) {
        core.info('ripgrep not found, installing it.')
        try {
          await exec('sudo', ['apt-get', 'update'])
          await exec('sudo', ['apt-get', 'install', '-y', '--no-install-recommends', 'ripgrep'])
        } catch (installError) {
          core.warning('Failed to install ripgrep, continuing without it.')
          if (installError instanceof Error) {
            core.warning(installError.message)
          }
        }
      }
    }

    // Get inputs
    const inputs = await getInputs()
    validateInputs(inputs)

    if (inputs.runnerPayload) {
      await remoteRunner({ runnerPayload: inputs.runnerPayload, cliVersion: inputs.cliVersion, runnerApiUrl: inputs.runnerApiUrl })
      return
    }

    if (inputs.review) {
      await handleReview(inputs)
      return
    }

    const octokit = github.getOctokit(process.env.GITHUB_TOKEN ?? '')
    const { owner, repo } = github.context.repo
    core.info(`Processing repository: ${owner}/${repo}`)

    // Get task description
    core.info('Fetching task description')
    let taskDescription = ''
    if (inputs.issueNumber) {
      core.info(`Fetching issue #${inputs.issueNumber}`)
      taskDescription = await fetchIssue({ owner, repo, issueNumber: inputs.issueNumber, octokit })
      core.debug(`Fetched issue description: ${taskDescription}`)
    } else if (inputs.prNumber) {
      core.info(`Fetching PR #${inputs.prNumber}`)
      taskDescription = await fetchPR({ owner, repo, prNumber: inputs.prNumber, octokit })
      core.debug(`Fetched PR description: ${taskDescription}`)
    }
    if (inputs.task) {
      taskDescription = `${inputs.task}\n\n${taskDescription}`
    }

    if (!taskDescription) {
      const error = 'No task description provided'
      core.error(error)
      throw new Error(error)
    }

    let configArgs: string[] = []
    if (inputs.config) {
      const configPaths = inputs.config.split(',').map(sanitizePath)
      configArgs = configPaths.flatMap((path) => ['--config', path])
      core.info(`Using config files: ${configPaths.join(', ')}`)
    }

    let branchName = ''

    if (inputs.prNumber) {
      // Checkout existing PR branch
      core.info(`Checking out PR #${inputs.prNumber}`)
      spawnSync('gh', ['pr', 'checkout', inputs.prNumber.toString()], { stdio: 'inherit' })
    } else {
      // Create a new branch for changes
      branchName = `polka/task-${Date.now()}`
      core.info(`Creating new branch: ${branchName}`)
      spawnSync('git', ['checkout', '-b', branchName], { stdio: 'inherit' })
    }

    core.info('Starting task processing')
    core.debug(`Task description: ${taskDescription}`)

    // Process task using Polka Codes CLI
    core.info('Executing Polka Codes CLI')
    spawnSync('npx', [`@polka-codes/cli@${inputs.cliVersion}`, ...configArgs, taskDescription], { stdio: 'inherit' })

    // Commit and push changes
    core.info('Committing changes')
    spawnSync('git', ['add', '.'], { stdio: 'inherit' })
    spawnSync('npx', [`@polka-codes/cli@${inputs.cliVersion}`, ...configArgs, 'commit'], { stdio: 'inherit' })
    core.info('Pushing changes')
    if (branchName) {
      core.info(`Pushing to branch: ${branchName}`)
      spawnSync('git', ['push', 'origin', branchName], { stdio: 'inherit' })
    } else {
      core.info('Pushing to current branch')
      spawnSync('git', ['push'], { stdio: 'inherit' })
    }

    const extraContent = inputs.issueNumber ? [`Closes #${inputs.issueNumber}`] : []
    spawnSync('npx', [`@polka-codes/cli@${inputs.cliVersion}`, ...configArgs, 'pr', ...extraContent], { stdio: 'inherit' })
  } catch (error) {
    if (error instanceof Error) {
      core.error(`Failed with error: ${error.message}`)
      core.error(`Stack trace: ${error.stack}`)
      core.setFailed(error.message)
    } else {
      core.error('An unexpected error occurred')
      core.setFailed('An unexpected error occurred')
    }
  }
}
