// Generated by polka.codes
// Main entry point for the Polka Codes GitHub Action

import { platform } from 'node:os'
import * as core from '@actions/core'
import { getExecOutput } from '@actions/exec'
import * as github from '@actions/github'
import { fetchIssue, fetchPR } from '@polka-codes/github'

interface SpecificReview {
  file: string
  lines: string // e.g., '10' or '10-15'
  review: string
}

interface ReviewOutput {
  overview: string
  specificReviews: SpecificReview[]
}

interface ActionInputs {
  issueNumber?: number
  prNumber?: number
  task?: string
  config?: string
  cliVersion: string
  runnerPayload?: string
  runnerApiUrl: string
  review: boolean
  verbose?: number
}

const coerceNumber = (value: string | undefined): number | undefined => {
  const v = value?.trim()
  if (!v) return undefined
  const n = Number.parseInt(v, 10)
  return Number.isFinite(n) && n > 0 ? n : undefined
}

const coerceBoolean = (value: string | undefined): boolean => value?.trim().toLowerCase() === 'true'

const generateVerboseFlags = (verbose?: number): string[] => {
  if (!verbose || verbose < 1) return []
  return [`-${'v'.repeat(Math.min(verbose, 5))}`]
}

async function getInputs(): Promise<ActionInputs> {
  core.debug('Getting action inputs')
  const issueNumberStr = core.getInput('issue_number')
  const prNumberStr = core.getInput('pr_number')
  const verboseStr = core.getInput('verbose')

  const inputs: ActionInputs = {
    issueNumber: coerceNumber(issueNumberStr),
    prNumber: coerceNumber(prNumberStr),
    task: core.getInput('task') || undefined,
    config: core.getInput('config') || undefined,
    cliVersion: core.getInput('cli_version') || 'latest',
    runnerPayload: core.getInput('runner_payload') || undefined,
    runnerApiUrl: core.getInput('runner_api_url'),
    review: coerceBoolean(core.getInput('review')),
    verbose: coerceNumber(verboseStr),
  }

  core.debug(
    `Received inputs: issue=${issueNumberStr}, pr=${prNumberStr}, task=${inputs.task ? '[provided]' : 'none'}, config=${inputs.config ?? 'none'}, review=${inputs.review}, verbose=${inputs.verbose ?? 'none'}`,
  )
  return inputs
}

const validateInputs = (inputs: ActionInputs) => {
  core.debug('Validating inputs')

  if (inputs.runnerPayload) {
    if (inputs.issueNumber || inputs.prNumber || inputs.task) {
      const error = 'issue_number, pr_number, or task cannot be used when used as remote runner'
      core.error(error)
      throw new Error(error)
    }
    return
  }

  if (inputs.review) {
    if (!inputs.prNumber && !inputs.issueNumber) {
      throw new Error('Review mode requires either a "pr_number" or "issue_number" input.')
    }
    if (inputs.task) {
      core.warning('The "task" input is ignored when in review mode.')
    }
    return
  }

  if (inputs.issueNumber && inputs.prNumber) {
    const error = 'Only one of issue_number or pr_number can be provided'
    core.error(error)
    throw new Error(error)
  }

  if (!inputs.issueNumber && !inputs.prNumber && !inputs.task) {
    const error = 'One of issue_number, pr_number, or task must be provided'
    core.error(error)
    throw new Error(error)
  }
}

const sanitizePath = (path: string): string => {
  const trimmedPath = path.trim()
  if (trimmedPath.includes('..') || /[&;|`<>!$*]/.test(trimmedPath)) {
    throw new Error(`Invalid or disallowed character in config path: ${trimmedPath}`)
  }
  return trimmedPath
}

// The result of a command execution
interface ExecResult {
  // The exit code of the command. Non-zero indicates failure.
  exitCode: number
  // The stdout of the command
  stdout: string
  // The stderr of the command
  stderr: string
}

const safeExec = async (cmd: string, args: string[]): Promise<ExecResult> => {
  const startedAt = Date.now()
  const pretty = `${cmd} ${args.join(' ')}`
  core.debug(`exec: ${pretty}`)

  try {
    const res = await getExecOutput(cmd, args, { ignoreReturnCode: true })

    const duration = Date.now() - startedAt
    const outcome = res.exitCode === 0 ? 'succeeded' : `failed (code ${res.exitCode})`
    core.debug(`exec ${outcome} in ${duration}ms: ${pretty}`)

    if (res.exitCode !== 0) {
      if (res.stderr) core.debug(`stderr: ${res.stderr}`)
      if (res.stdout) core.debug(`stdout: ${res.stdout}`)
    }

    return { exitCode: res.exitCode, stdout: res.stdout, stderr: res.stderr }
  } catch (e) {
    const duration = Date.now() - startedAt
    core.debug(`exec failed in ${duration}ms: ${pretty}`)
    if (e instanceof Error) {
      core.debug(e.message)
    }
    return { exitCode: 1, stdout: '', stderr: e instanceof Error ? e.message : 'Unknown error' }
  }
}

const parseJson = <T>(raw: string, context: string): T => {
  try {
    return JSON.parse(raw) as T
  } catch (e) {
    core.error(`Failed to parse JSON for ${context}`)
    core.debug(`Raw JSON: ${raw}`)
    throw e instanceof Error ? e : new Error('JSON parse error')
  }
}

const remoteRunner = async (inputs: { runnerPayload: string; cliVersion: string; runnerApiUrl: string }) => {
  const payload = parseJson<{ ref?: string; taskId: string; sessionToken: string }>(inputs.runnerPayload, 'runnerPayload')
  if (payload.ref) {
    const fetchResult = await safeExec('git', ['fetch', 'origin', payload.ref])
    if (fetchResult.exitCode !== 0) {
      throw new Error(`git fetch failed with exit code ${fetchResult.exitCode}`)
    }
    const checkoutResult = await safeExec('git', ['checkout', payload.ref])
    if (checkoutResult.exitCode !== 0) {
      throw new Error(`git checkout failed with exit code ${checkoutResult.exitCode}`)
    }
  }
  const oidcToken = await core.getIDToken('https://polka.codes')

  const apiParams = inputs.runnerApiUrl ? ['--api', inputs.runnerApiUrl] : []

  await safeExec('npx', [
    `@polka-codes/runner@${inputs.cliVersion}`,
    '--task-id',
    payload.taskId,
    '--session-token',
    payload.sessionToken,
    '--github-token',
    oidcToken,
    ...apiParams,
  ])
}

interface DiffHunk {
  startLine: number
  lineCount: number
}

interface FileChangeInfo {
  filename: string
  hunks: DiffHunk[]
}

const parseDiffHunks = (patch: string): DiffHunk[] => {
  const hunks: DiffHunk[] = []
  const lines = patch.split('\n')

  for (const line of lines) {
    const hunkHeader = line.match(/^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@/)
    if (hunkHeader) {
      const startLine = Number.parseInt(hunkHeader[1], 10)
      const lineCount = hunkHeader[2] ? Number.parseInt(hunkHeader[2], 10) : 1
      hunks.push({ startLine, lineCount })
    }
  }

  return hunks
}

const isLineInDiff = (filename: string, line: number, fileChanges: Map<string, FileChangeInfo>): boolean => {
  const fileInfo = fileChanges.get(filename)
  if (!fileInfo) {
    return false
  }

  return fileInfo.hunks.some((hunk) => {
    const endLine = hunk.startLine + hunk.lineCount - 1
    return line >= hunk.startLine && line <= endLine
  })
}

const isRangeInDiff = (filename: string, startLine: number, endLine: number, fileChanges: Map<string, FileChangeInfo>): boolean => {
  const fileInfo = fileChanges.get(filename)
  if (!fileInfo) {
    return false
  }

  return fileInfo.hunks.some((hunk) => {
    const hunkEndLine = hunk.startLine + hunk.lineCount - 1
    return startLine >= hunk.startLine && endLine <= hunkEndLine
  })
}

async function handleReview(inputs: ActionInputs): Promise<void> {
  core.info('Starting review process...')
  const octokit = github.getOctokit(process.env.GITHUB_TOKEN ?? '')
  const { owner, repo } = github.context.repo

  const getPrData = async (prNumber: number) => {
    core.info(`Fetching PR #${prNumber} for base branch information.`)
    const { data: prData } = await octokit.rest.pulls.get({ owner, repo, pull_number: prNumber })
    const baseBranchRef = prData.base.ref
    core.info(`Base branch is '${baseBranchRef}'. Fetching...`)
    const fetchResult = await safeExec('git', ['fetch', 'origin', baseBranchRef])
    if (fetchResult.exitCode !== 0) {
      core.warning(`git fetch origin ${baseBranchRef} failed. This may cause issues with the review.`)
    }
    return prData
  }

  const getPrFiles = async (prNumber: number): Promise<Map<string, FileChangeInfo>> => {
    core.info(`Fetching PR #${prNumber} files for diff validation.`)
    const { data: files } = await octokit.rest.pulls.listFiles({ owner, repo, pull_number: prNumber })

    const fileChanges = new Map<string, FileChangeInfo>()

    for (const file of files) {
      if (file.patch && (file.status === 'modified' || file.status === 'added' || file.status === 'renamed')) {
        const hunks = parseDiffHunks(file.patch)
        fileChanges.set(file.filename, {
          filename: file.filename,
          hunks,
        })
        core.debug(`Parsed ${hunks.length} diff hunks for file: ${file.filename}`)
      }
    }

    return fileChanges
  }

  const pr = inputs.prNumber ? await getPrData(inputs.prNumber) : undefined
  const fileChanges = inputs.prNumber ? await getPrFiles(inputs.prNumber) : new Map<string, FileChangeInfo>()

  let configArgs: string[] = []
  if (inputs.config) {
    const configPaths = inputs.config.split(',').map(sanitizePath)
    configArgs = configPaths.flatMap((p) => ['--config', p])
    core.info(`Using config files for review: ${configPaths.join(', ')}`)
  }

  const verboseFlags = generateVerboseFlags(inputs.verbose)
  if (verboseFlags.length > 0) {
    core.info(`Using verbosity flags: ${verboseFlags.join(' ')}`)
  }

  core.info('Executing review command...')
  const reviewCommand = await safeExec('npx', [
    `@polka-codes/cli@${inputs.cliVersion}`,
    ...configArgs,
    ...verboseFlags,
    'review',
    '--json',
    '--pr',
    String(inputs.prNumber),
  ])

  if (reviewCommand.exitCode !== 0) {
    const errorMessage = `Review command failed with exit code ${reviewCommand.exitCode}`
    core.error(errorMessage)
    core.error(`stderr: ${reviewCommand.stderr}`)
    if (reviewCommand.stdout) core.error(`stdout: ${reviewCommand.stdout}`)
    throw new Error(errorMessage)
  }

  const jsonOutput = reviewCommand.stdout
  const reviewData = parseJson<ReviewOutput>(jsonOutput, 'review output JSON')

  const { overview, specificReviews } = reviewData
  const issue_number = inputs.prNumber ?? inputs.issueNumber

  if (!issue_number) {
    throw new Error('No PR or issue number found for review posting.')
  }

  const postCombinedComment = async (body: string, reviews: SpecificReview[]) => {
    let combinedBody = body
    if (reviews.length > 0) {
      const reviewsBody = reviews.map(({ file, lines, review }) => `**${file}:${lines}**\n\n${review}`).join('\n\n---\n\n')
      combinedBody += `\n\n---\n\n### Review Suggestions\n\n${reviewsBody}`
    }
    core.info(`Posting comment to #${issue_number}: \n${combinedBody}`)
    await octokit.rest.issues.createComment({ owner, repo, issue_number, body: combinedBody })
  }

  if (specificReviews.length > 0 && inputs.prNumber) {
    core.info(`Posting a PR review with up to ${specificReviews.length} specific comments.`)

    if (!pr) {
      throw new Error('PR data not available for review.')
    }

    const parseLines = (lines: string): { line: number; start_line?: number } | null => {
      const trimmedLines = lines.trim()
      if (/^\d+$/.test(trimmedLines)) {
        const line = Number(trimmedLines)
        return line > 0 ? { line } : null
      }
      if (/^\d+-\d+$/.test(trimmedLines)) {
        const [start, end] = trimmedLines.split('-').map((n) => Number(n))
        if (start >= 1 && end >= start) return { start_line: start, line: end }
      }
      core.warning(`Invalid lines format: "${lines}". It will be included in the main comment.`)
      return null
    }

    type CreateReviewParameters = NonNullable<Parameters<typeof octokit.rest.pulls.createReview>[0]>
    type ReviewComments = NonNullable<CreateReviewParameters['comments']>
    const postableComments: ReviewComments = []
    const unpostableReviews: SpecificReview[] = []

    for (const review of specificReviews) {
      const lineInfo = parseLines(review.lines)
      if (lineInfo) {
        let canPost = false

        if (lineInfo.start_line !== undefined) {
          // For range comments, check if the range overlaps with diff
          canPost = isRangeInDiff(review.file, lineInfo.start_line, lineInfo.line, fileChanges)
        } else {
          // For single line comments, check if the line is in diff
          canPost = isLineInDiff(review.file, lineInfo.line, fileChanges)
        }

        if (canPost) {
          const comment: ReviewComments[0] = {
            path: review.file,
            body: review.review,
            line: lineInfo.line,
            side: 'RIGHT',
          }
          if (lineInfo.start_line) {
            comment.start_line = lineInfo.start_line
            comment.start_side = 'RIGHT'
          }
          postableComments.push(comment)
        } else {
          core.debug(`Comment for ${review.file}:${review.lines} not in diff, moving to unpostable reviews`)
          unpostableReviews.push(review)
        }
      } else {
        unpostableReviews.push(review)
      }
    }

    let reviewBody = overview ?? ''
    if (unpostableReviews.length > 0) {
      const unpostableBody = unpostableReviews.map(({ file, lines, review }) => `**${file}:${lines}**\n\n${review}`).join('\n\n---\n\n')
      reviewBody += `\n\n---\n\n### Suggestions that couldn't be attached to a specific line\n\n${unpostableBody}`
    }

    if (postableComments.length > 0) {
      try {
        await octokit.rest.pulls.createReview({
          owner,
          repo,
          pull_number: inputs.prNumber,
          commit_id: pr.head.sha,
          body: reviewBody,
          event: 'COMMENT',
          comments: postableComments,
        })
      } catch (error) {
        const message = `Failed to create PR review. Falling back to a general comment. Error: ${
          error instanceof Error ? error.message : 'Unknown error'
        }`
        core.warning(message)
        await postCombinedComment(overview ?? '', specificReviews)
      }
    } else {
      await postCombinedComment(overview ?? '', specificReviews)
    }
  } else if (overview || specificReviews.length > 0) {
    await postCombinedComment(overview ?? '', specificReviews)
  } else {
    core.info('No overview or specific reviews to post.')
  }
}

export async function run(): Promise<void> {
  try {
    const actionStart = Date.now()
    core.startGroup('Environment setup')
    if (platform() === 'linux') {
      const rgCheck = await safeExec('rg', ['--version'])
      if (rgCheck.exitCode === 0) {
        core.debug('ripgrep is already installed.')
      } else {
        core.info('ripgrep not found, installing it.')
        const aptUpdate = await safeExec('sudo', ['apt-get', 'update'])
        if (aptUpdate.exitCode !== 0) {
          throw new Error(`apt-get update failed with exit code ${aptUpdate.exitCode}`)
        }
        const rgInstall = await safeExec('sudo', ['apt-get', 'install', '-y', '--no-install-recommends', 'ripgrep'])
        if (rgInstall.exitCode !== 0) {
          throw new Error(`ripgrep installation failed with exit code ${rgInstall.exitCode}`)
        }
      }
    }
    core.endGroup()

    core.startGroup('Read and validate inputs')
    const inputs = await getInputs()
    validateInputs(inputs)
    core.info(`Mode: ${inputs.runnerPayload ? 'remote-runner' : inputs.review ? 'review' : 'task'}`)
    core.endGroup()

    if (inputs.runnerPayload) {
      core.startGroup('Remote runner')
      await remoteRunner({ runnerPayload: inputs.runnerPayload, cliVersion: inputs.cliVersion, runnerApiUrl: inputs.runnerApiUrl })
      core.endGroup()
      core.info(`Completed in ${Date.now() - actionStart}ms`)
      return
    }

    if (inputs.review) {
      core.startGroup('Review mode')
      await handleReview(inputs)
      core.endGroup()
      core.info(`Completed in ${Date.now() - actionStart}ms`)
      return
    }

    const octokit = github.getOctokit(process.env.GITHUB_TOKEN ?? '')
    const { owner, repo } = github.context.repo
    core.info(`Processing repository: ${owner}/${repo}`)

    core.info('Fetching task description')
    let taskDescription = ''
    if (inputs.issueNumber) {
      core.startGroup(`Fetch issue #${inputs.issueNumber}`)
      taskDescription = await fetchIssue({ owner, repo, issueNumber: inputs.issueNumber, octokit })
      core.debug(`Fetched issue description length: ${taskDescription.length}`)
      core.endGroup()
    } else if (inputs.prNumber) {
      core.startGroup(`Fetch PR #${inputs.prNumber}`)
      taskDescription = await fetchPR({ owner, repo, prNumber: inputs.prNumber, octokit })
      core.debug(`Fetched PR description length: ${taskDescription.length}`)
      core.endGroup()
    }
    if (inputs.task) {
      taskDescription = `${inputs.task}\n\n${taskDescription}`
    }

    if (!taskDescription) {
      const error = 'No task description provided'
      core.error(error)
      throw new Error(error)
    }

    let configArgs: string[] = []
    if (inputs.config) {
      const configPaths = inputs.config.split(',').map(sanitizePath)
      configArgs = configPaths.flatMap((p) => ['--config', p])
      core.info(`Using config files: ${configPaths.join(', ')}`)
    }

    const verboseFlags = generateVerboseFlags(inputs.verbose)
    if (verboseFlags.length > 0) {
      core.info(`Using verbosity flags: ${verboseFlags.join(' ')}`)
    }

    let branchName = ''

    if (inputs.prNumber) {
      core.startGroup(`Checkout PR #${inputs.prNumber}`)
      await safeExec('gh', ['pr', 'checkout', String(inputs.prNumber)])
      core.endGroup()
    } else {
      branchName = `polka/task-${Date.now()}`
      core.startGroup(`Create branch ${branchName}`)
      await safeExec('git', ['checkout', '-b', branchName])
      core.endGroup()
    }

    core.startGroup('Run Polka Codes CLI')
    core.debug(`Task description length: ${taskDescription.length}`)
    await safeExec('npx', [`@polka-codes/cli@${inputs.cliVersion}`, ...configArgs, ...verboseFlags, taskDescription])
    core.endGroup()

    core.startGroup('Commit and push changes')
    const addResult = await safeExec('git', ['add', '.'])
    if (addResult.exitCode !== 0) {
      throw new Error(`git add failed with exit code ${addResult.exitCode}`)
    }
    await safeExec('npx', [`@polka-codes/cli@${inputs.cliVersion}`, ...configArgs, ...verboseFlags, 'commit'])
    if (branchName) {
      core.info(`Pushing to branch: ${branchName}`)
      await safeExec('git', ['push', 'origin', branchName])
    } else {
      core.info('Pushing to current branch')
      await safeExec('git', ['push'])
    }
    core.endGroup()

    core.startGroup('Open PR')
    const extraContent = inputs.issueNumber ? [`Closes #${inputs.issueNumber}`] : []
    await safeExec('npx', [`@polka-codes/cli@${inputs.cliVersion}`, ...configArgs, ...verboseFlags, 'pr', ...extraContent])
    core.endGroup()
  } catch (error) {
    if (error instanceof Error) {
      core.error(`Failed with error: ${error.message}`)
      core.error(`Stack trace: ${error.stack}`)
      core.setFailed(error.message)
    } else {
      core.error('An unexpected error occurred')
      core.setFailed('An unexpected error occurred')
    }
  }
}
